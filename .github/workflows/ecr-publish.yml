name: ECR Dependencies and Push Images
on:
  workflow_call:
    inputs:
      revision:
        description: "The revision number to use for construction (computed from the Dockerfile if not provided)"
        required: false
        type: string
    secrets:
      ECR_AWS_REGION:
        required: true
      ECR_AWS_ORG_ID:
        required: true
      ECR_AWS_ACCESS_KEY:
        required: true
      ECR_AWS_ACCOUNT_ID:
        required: true
      ECR_AWS_SECRET_ACCESS_KEY:
        required: true
      ALF_QUAY_IO_USERNAME:
        required: false
      ALF_QUAY_IO_PASSWORD:
        required: false
      CURL_ENCRYPTION_KEY:
        required: false
      CURL_AUTH_FILE:
        required: false
      CURL_USERNAME:
        required: false
      CURL_PASSWORD:
        required: false
      MVN_GET_ENCRYPTION_KEY:
        required: false
      MVN_GET_USERNAME:
        required: false
      MVN_GET_PASSWORD:
        required: false

env:
  ECR_AWS_REGION: ${{ secrets.ECR_AWS_REGION }}
  ECR_AWS_ORG_ID: ${{ secrets.ECR_AWS_ORG_ID }}
  GH_TOKEN: ${{ github.token }}

jobs:
  ECR-Publishing:
    runs-on: ubuntu-latest
    steps:
      - name: Validate the parameters
        env:
          ARM_REVISION: ${{ inputs.revision }}
        run: |
          if [ -n "${ARM_REVISION}" ] ; then
              # Parse for vailidity ... we'll examine it more closely later
              if [[ ! "${ARM_REVISION}" =~ ^((0|[1-9][0-9]*)([.][0-9]+)*)(-([a-zA-Z0-9-]+([.][a-zA-Z0-9-]+)*))?([+]([a-zA-Z0-9-]+))?$ ]] ; then
                  echo "Revision number is not valid: [${ARM_REVISION}]"
                  exit 1
              fi
          fi

      - name: Checkout source code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.ECR_AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.ECR_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.ECR_AWS_REGION }}
          mask-aws-account-id: ${{ secrets.ECR_AWS_ACCOUNT_ID }}

      - name: Initialize the environment file
        env:
          ARM_REVISION: ${{ inputs.revision }}
        run: |
          # Start with a clean environment
          : > .env

          echo "export ARM_REVISION=${ARM_REVISION@Q}" >> .env
          echo "ARM_REVISION=${ARM_REVISION@Q}"

          TIMESTAMP="$(date -u +%Y%m%d%H%M%S)"
          echo "export TIMESTAMP=${TIMESTAMP@Q}" >> .env
          echo "TIMESTAMP=${TIMESTAMP@Q}"

      - name: Docker Login to Alfresco Quay.IO (if applicable)
        env:
          ALF_QUAY_IO_USERNAME: ${{ secrets.ALF_QUAY_IO_USERNAME }}
          ALF_QUAY_IO_PASSWORD: ${{ secrets.ALF_QUAY_IO_PASSWORD }}
        run: |
          source .env
          cat .env

          if [ -v ALF_QUAY_IO_USERNAME ] && [ -v ALF_QUAY_IO_PASSWORD ] && [ -n "${ALF_QUAY_IO_USERNAME}" ] && [ -n "${ALF_QUAY_IO_PASSWORD}" ] ; then
              docker login -u "${ALF_QUAY_IO_USERNAME}" -p "${ALF_QUAY_IO_PASSWORD}" quay.io
          else
              [ -v ALF_QUAY_IO_USERNAME ] || [ -v ALF_QUAY_IO_PASSWORD ] && echo "These are the quay.io credentials given (sha256sum):"
              [ -v ALF_QUAY_IO_USERNAME ] && echo -e "\tUSERNAME: [$(echo -n "${ALF_QUAY_IO_USERNAME}" | sha256sum)]"
              [ -v ALF_QUAY_IO_PASSWORD ] && echo -e "\tPASSWORD: [$(echo -n "${ALF_QUAY_IO_PASSWORD}" | sha256sum)]"
              echo "The quay.io credentials were insufficient. Will not authenticate."
          fi

        # The AWS login needs to happen before the build b/c the
        # ECR_REGISTRY_PRIVATE value is computed here
      - name: Login to Amazon ECR (Private)
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

        # The AWS login needs to happen before the build b/c the
        # ECR_REGISTRY_PUBLIC value is computed here
      - name: Login to Amazon ECR (Public)
        id: login-ecr-public
        uses: aws-actions/amazon-ecr-login@v1
        with:
          registry-type: public

      - name: Identify the build's characteristics (visibility, version number, etc)
        env:
          ARM_REVISION: ${{ inputs.revision }}
          ECR_REGISTRY_PRIVATE: ${{ steps.login-ecr.outputs.registry }}
          ECR_REGISTRY_PUBLIC: ${{ steps.login-ecr-public.outputs.registry }}
        run: |
          source .env
          cat .env

          # Check to see the project's visibility
          # TODO: CHECK THE DOCKERFILE FOR A REQUEST (ARG) TO KEEP THE BUILD PRIVATE
          export PRIVATE="$(gh repo view --json isPrivate --jq .isPrivate)"
          export VISIBILITY="private"
          "${PRIVATE}" || VISIBILITY="public"

          echo "export VISIBILITY=${VISIBILITY@Q}" >> .env
          echo "VISIBILITY=${VISIBILITY@Q}"

          # Split into an array of parts, making sure that double slashes, if present, are condensed into one
          # Also remove leading and trailing slashes, for safety. Also, fold it to lowercase
          readarray -d / -t PARTS < <(echo -n "${GITHUB_REPOSITORY,,}" | sed -e "s;^/*;;g" -e "s;/*$;;g" -e "s;/\+;/;g")

          # So at this point we know that PARTS[0] is the product suite (ArkCase, for instance), and PARTS[1] is the
          # repository name (i.e. ark_something-or-other)
          # Change out underscores for dashes
          export PRODUCT_SUITE="${PARTS[0]//_/-}"
          export IMAGE_NAME="${PARTS[1]//_/-}"

          # Also, to support more product suites in the future...
          case "${PRODUCT_SUITE}" in
              "arkcase" ) IMAGE_NAME="$(echo -n "${IMAGE_NAME}" | sed -e "s;^ark-;;g")" ;;
          esac

          echo "export PRODUCT_SUITE=${PRODUCT_SUITE@Q}" >> .env
          echo "PRODUCT_SUITE=${PRODUCT_SUITE@Q}"
          echo "export IMAGE_NAME=${IMAGE_NAME@Q}" >> .env
          echo "IMAGE_NAME=${IMAGE_NAME@Q}"

          export IMAGE_URI="${PRODUCT_SUITE}/${IMAGE_NAME}"
          echo "export IMAGE_URI=${IMAGE_URI@Q}" >> .env
          echo "IMAGE_URI=${IMAGE_URI@Q}"

          # Make sure it's defined if it isn't already
          REVISION="${ARM_REVISION}"
          if [ -z "${REVISION}" ] ; then
              # Parse out the tag, handle the case when it's not there
              read REVISION < <(
                  set -eo pipefail

                  # Parsing out the version from the "VER" argument can be tricky if it's computed from others
                  # values or arguments, so let's try it with some sneaky trickery.

                  # We have to resort to Perl's evil black magic b/c we have to cover the edge case of
                  # line continuations - we have to collapse those, first... then we can find the ARG clauses,
                  # and finally convert them all into bash "export" clauses ... which we then consume (this is
                  # why redefinition is an issue, above). We use a PREFIX to avoid name clashes with read-only
                  # BASH variables which can cause the task to fail, and we use special SED strings to add the
                  # prefix as necessary for variable expansion among the arguments themselves
                  export PREFIX="____DOCKER_ARG____"

                  # It's OK to define these here ... if they get overridden below, we're happy about it.
                  # Otherwise, we fall back to these values to avoid failing the parse.
                  eval export "${PREFIX}PRIVATE_REGISTRY=${ECR_REGISTRY_PRIVATE@Q}"
                  eval export "${PREFIX}PUBLIC_REGISTRY=${ECR_REGISTRY_PUBLIC@Q}"
                  eval export "${PREFIX}BASE_REGISTRY=${ECR_REGISTRY_PRIVATE@Q}"

                  source <(
                      perl -pe "s/\\\s*$//" Dockerfile | \
                          egrep '^[[:space:]]*ARG[[:space:]]+[^=]+=' | \
                          sed -e "s;\${;\$\{${PREFIX};g" \
                              -e "s;\$\([^{]\);\$${PREFIX}\1;g" | \
                          sed -e "s;^\s*ARG\s;export ${PREFIX};g"
                  )

                  REVISION_CANDIDATES=()
                  REVISION_CANDIDATES+=("VER")
                  # TODO: do we want to support many possible version sources? i.e. VER, VERSION,
                  # IMAGEVER, IMAGE_VERSION, etc?
                  # REVISION_CANDIDATES+=("VERSION")
                  # REVISION_CANDIDATES+=("IMAGEVER")
                  # REVISION_CANDIDATES+=("IMAGEVERSION")
                  # REVISION_CANDIDATES+=("IMAGE_VERSION")
                  for C in "${REVISION_CANDIDATES[@]}" ; do
                      [ -z "${PREFIX}" ] || C="${PREFIX}${C}"
                      # This checks to see if the candidate is defined, and if it has a non-blank
                      # value. If both are met, then its value is output, and the loop is broken
                      [ -v "${C}" ] || continue
                      [ -n "${!C}" ] || continue
                      echo "${!C}"
                      break
                  done
              )
              RC=${?}

              if [ ${RC} -ne 0 ] ; then
                  echo "Failed to compute the build version from the Dockerfile (rc=${RC})"
                  exit ${RC}
              fi

              if [ -z "${REVISION}" ] ; then
                  echo "Failed to compute a build version from the Dockerfile"
                  exit 1
              fi
          fi

          # Parse for vailidity ... we'll examine it more closely later
          #
          # This is inspired by, but not strictly adhering to, semantic versioning. It deviates
          # in the following ways:
          #
          #     * Leading zeros are allowed on all but the first component of the version number
          #     * More than 3 dot-separated components are allowed on the version number
          #
          # Otherwise, the rest is the same: same rules for pre-release tags and metadata tags.
          if [[ ! "${REVISION}" =~ ^((0|[1-9][0-9]*)([.][0-9]+)*)(-([a-zA-Z0-9-]+([.][a-zA-Z0-9-]+)*))?([+]([a-zA-Z0-9-]+))?$ ]] ; then
              echo "Revision number is not valid: [${REVISION}]"
              exit 1
          fi

          BASE_NUMBER="${BASH_REMATCH[1]}"
          PRERELEASE="${BASH_REMATCH[5]}"
          METADATA="${BASH_REMATCH[8]}"

          # If the pre-release info is a "SNAPSHOT", make sure it's used properly
          REVISION_SNAPSHOT="false"
          if [[ "${PRERELEASE}" =~ SNAPSHOT ]] ; then
              if [[ "${PRERELEASE}" =~ (^|[^a-zA-Z0-9_])SNAPSHOT($|[^a-zA-Z0-9_]) ]] ; then
                  REVISION_SNAPSHOT="true"
              else
                  echo "Illegal use of the word 'SNAPSHOT' as [${PRERELASE}] - must be a standalone word: [${REVISION}]"
                  exit 1
              fi
          fi

          # Assume the default is "devel", until proven otherwise
          export ENVIRONMENT="devel"
          export PREFIX="devel-"
          # This makes it easier to add special branch handlers later on
          case "${GITHUB_REF}" in
              "refs/heads/main" ) ENVIRONMENT="stable" ; PREFIX="" ;;
          esac
          echo "export ENVIRONMENT=${ENVIRONMENT@Q}" >> .env
          echo "ENVIRONMENT=${ENVIRONMENT@Q}"

          echo "export REVISION=${REVISION@Q}" >> .env
          echo "export REVISION_PREFIX=${PREFIX@Q}" >> .env
          echo "export REVISION_BASE_NUMBER=${BASE_NUMBER@Q}" >> .env
          echo "export REVISION_PRERELEASE=${PRERELEASE@Q}" >> .env
          echo "export REVISION_METADATA=${METADATA@Q}" >> .env
          echo "export REVISION_SNAPSHOT=${REVISION_SNAPSHOT@Q}" >> .env
          echo "REVISION=${REVISION@Q}"
          echo "REVISION_PREFIX=${PREFIX@Q}"
          echo "REVISION_BASE_NUMBER=${BASE_NUMBER@Q}"
          echo "REVISION_PRERELEASE=${PRERELEASE@Q}"
          echo "REVISION_METADATA=${METADATA@Q}"
          echo "REVISION_SNAPSHOT=${REVISION_SNAPSHOT@Q}"

          # We only push to public if this is a public repository,
          # AND this build is not a pre-release build
          export PUSH_TO_PUBLIC="false"
          [ "${ENVIRONMENT}" == "stable" ] && [ "${VISIBILITY}" == "public" ] && [ -z "${PRERELEASE}" ] && PUSH_TO_PUBLIC="true"
          echo "export PUSH_TO_PUBLIC=${PUSH_TO_PUBLIC@Q}" >> .env
          echo "PUSH_TO_PUBLIC=${PUSH_TO_PUBLIC@Q}"

      - name: Build the Docker image
        env:
          ECR_REGISTRY_PRIVATE: ${{ steps.login-ecr.outputs.registry }}
          ECR_REGISTRY_PUBLIC: ${{ steps.login-ecr-public.outputs.registry }}
          ECR_AWS_REGION: ${{ secrets.ECR_AWS_REGION }}
          ECR_AWS_ACCESS_KEY: ${{ secrets.ECR_AWS_ACCESS_KEY }}
          ECR_AWS_SECRET_ACCESS_KEY: ${{ secrets.ECR_AWS_SECRET_ACCESS_KEY }}
          CURL_ENCRYPTION_KEY: ${{ secrets.CURL_ENCRYPTION_KEY }}
          CURL_AUTH_FILE: ${{ secrets.CURL_AUTH_FILE }}
          CURL_USERNAME: ${{ secrets.CURL_USERNAME }}
          CURL_PASSWORD: ${{ secrets.CURL_PASSWORD }}
          MVN_GET_ENCRYPTION_KEY: ${{ secrets.MVN_GET_ENCRYPTION_KEY }}
          MVN_GET_AUTH_FILE: ${{ secrets.MVN_GET_AUTH_FILE }}
          MVN_GET_USERNAME: ${{ secrets.MVN_GET_USERNAME }}
          MVN_GET_PASSWORD: ${{ secrets.MVN_GET_PASSWORD }}
        run: |
          source .env
          cat .env

          # Set any build arguments with private values
          export BUILD_ARGS=()

          # Always use the base version for this ...
          BUILD_ARGS+=(--build-arg "VER=${REVISION}")

          # Select the base registries
          BUILD_ARGS+=(--build-arg "PRIVATE_REGISTRY=${ECR_REGISTRY_PRIVATE}")
          BUILD_ARGS+=(--build-arg "PUBLIC_REGISTRY=${ECR_REGISTRY_PUBLIC}")

          # Select which one is the BASE registry, based on whether this
          # container is to be pushed to public or not
          BASE_REGISTRY="${ECR_REGISTRY_PRIVATE}"
          "${PUSH_TO_PUBLIC}" && BASE_REGISTRY="${ECR_REGISTRY_PUBLIC}"
          BUILD_ARGS+=(--build-arg "BASE_REGISTRY=${BASE_REGISTRY}")

          # Next, add all the stuff S3 will need to pull crap
          BUILD_ARGS+=(--build-arg "AWS_ACCESS_KEY_ID=${ECR_AWS_ACCESS_KEY}")
          BUILD_ARGS+=(--build-arg "AWS_SECRET_ACCESS_KEY=${ECR_AWS_SECRET_ACCESS_KEY}")
          BUILD_ARGS+=(--build-arg "AWS_REGION=${ECR_AWS_REGION}")

          # Add the Maven and CURL authentication deetz
          for VAR in "${!CURL_@}" "${!MVN_GET_@}" ; do
              BUILD_ARGS+=(--build-arg "${VAR}=${!VAR}")
          done

          # Final details for more complete information
          BUILD_ARGS+=(--label "GIT_REPOSITORY=${GITHUB_REPOSITORY}")
          BUILD_ARGS+=(--label "GIT_REF=${GITHUB_REF_NAME}")
          BUILD_ARGS+=(--label "GIT_REF_TYPE=${GITHUB_REF_TYPE}")
          BUILD_ARGS+=(--label "GIT_COMMIT=${GITHUB_SHA}")
          BUILD_ARGS+=(--label "GIT_BUILD_NUMBER=${GITHUB_RUN_NUMBER}")
          BUILD_ARGS+=(--label "GIT_BUILD_TIMESTAMP=${TIMESTAMP}")

          COMMIT_COUNT="$(git rev-list --count HEAD)"
          BUILD_ARGS+=(--label "GIT_COMMIT_COUNT=${COMMIT_COUNT}")

          #
          # These are the revisions that will be built
          #    ${REVISION_BASE_NUMBER}${REVISION_PRERELEASE}
          #    ${REVISION_BASE_NUMBER}${REVISION_PRERELEASE}_b${GITHUB_RUN_NUMBER}${REVISION_METADATA}
          #    ${REVISION_BASE_NUMBER}${REVISION_PRERELEASE}_b${GITHUB_RUN_NUMBER}-${TIMESTAMP}${REVISION_METADATA}
          #
          # The ordering of components is important for detemining who gets
          # the "latest" (or devel-latest) tag.
          #
          # The significance of components when comparing is:
          #
          #    * REVISION_BASE_NUMBER
          #    * GITHUB_RUN_NUMBER
          #    * TIMESTAMP
          #    * REVISION_METADATA
          #
          # We don't take into account the pre-release stuff b/c those will never get tagged as
          # "latest" because they're *pre-release* artifacts (this includes SNAPSHOT artifacts).
          #
          # This also applies to "devel" artifacts, since these aren't inteded to be public. However,
          # we do have a "devel-latest" which can be useful.
          #

          # If we have a pre-release tag, pre-pend a dash
          [ -n "${REVISION_PRERELEASE}" ] && REVISION_PRERELEASE="-${REVISION_PRERELEASE}"

          # This will house all the different revisions by which this
          # artifact will be known
          REVISIONS=()

          # NOTE: we use "_" instead of "+" as the revision metadata
          # separator here b/c the plus sign is not permitted in Docker tags

          # The first metadata must be appended with a leading underscore
          REVISIONS+=("${REVISION_PREFIX}${REVISION_BASE_NUMBER}${REVISION_PRERELEASE}${REVISION_METADATA:+_}${REVISION_METADATA}")

          # For the other builds, if there's any metadata, it will need a dash up front
          [ -n "${REVISION_METADATA}" ] && REVISION_METADATA="-${REVISION_METADATA}"

          # This is an intermediate revision with a little more build metadata
          REVISIONS+=("${REVISION_PREFIX}${REVISION_BASE_NUMBER}${REVISION_PRERELEASE}_b${GITHUB_RUN_NUMBER}${REVISION_METADATA}")

          # This is the most exact revision, which will be used for "latest" computation
          LATEST_REVISION="${REVISION_PREFIX}${REVISION_BASE_NUMBER}${REVISION_PRERELEASE}_b${GITHUB_RUN_NUMBER}-${TIMESTAMP}${REVISION_METADATA}"
          REVISIONS+=("${LATEST_REVISION}")

          TARGETS=()
          TARGETS+=("${ECR_REGISTRY_PRIVATE}/${IMAGE_URI}")
          "${PUSH_TO_PUBLIC}" && TARGETS+=("${ECR_REGISTRY_PUBLIC}/${IMAGE_URI}")

          # Set the build tags to be built. Make sure to cover
          # both targets if applicable
          TAGS=()
          echo "export BUILDS=()" >> .env
          for T in "${TARGETS[@]}" ; do
              for R in "${REVISIONS[@]}" ; do
                  BUILD="${T}:${R}"
                  echo "BUILDS+=(${BUILD@Q})" >> .env
                  TAGS+=(--tag "${BUILD}")
              done
          done

          # We only compute the need for a "latest" tag if
          # this is not a pre-release artifact.
          if [ -z "${REVISION_PRERELEASE}" ] ; then
              #
              # Identify if we need to bear the tag of "latest" per the
              # version precedence rules laid out above
              #

              # Since we know we won't have any pre-release stuff, we can
              # construct this selector regex to not allow any pre-release
              # information on the tags. We don't really care about metadata
              # since it's the LAST component to be taken into account, and
              # it most likely will never come into play since the timestamp
              # will almost assuredly NEVER coincide.
              RE_REVISION_SELECTOR="^${REVISION_PREFIX}[^-]+_b[0-9]+-[1-9][0-9]{13}"
              JQ_FIND_IMAGE_TAGS='.imageDetails[] | select(has("imageTags")) | .imageTags[]'

              # For re-use...
              LATEST="${REVISION_PREFIX}latest"
              LATEST_ADDED="false"

              # First, check the private revisions, ingoring pre-release stuff
              LATEST_PRV="$(
                  (
                      # We print out our latest revision so they get sorted properly
                      # alongside all other revisions. This way the post-processing
                      # sort+grep+head will yield the revision that should carry the
                      # "latest" moniker
                      echo "${LATEST_REVISION}"
                      aws ecr describe-images --repository-name "${IMAGE_URI}" | \
                          jq -r "${JQ_FIND_IMAGE_TAGS}"
                  ) | \
                  egrep "${RE_REVISION_SELECTOR}" | \
                  sort --reverse --version-sort --unique | \
                  head -1
              )"
              if [ "${LATEST_PRV}" == "${LATEST_REVISION}" ] ; then
                  BUILD="${ECR_REGISTRY_PRIVATE}/${IMAGE_URI}:${LATEST}"
                  echo "BUILDS+=(${BUILD@Q})" >> .env
                  TAGS+=(--tag "${BUILD}")
                  "${LATEST_ADDED}" || REVISIONS+=("${LATEST}")
                  LATEST_ADDED="true"
              fi

              if "${PUSH_TO_PUBLIC}" ; then
                  # Next, check the public one
                  LATEST_PUB="$(
                      (
                          # We print out our latest revision so they get sorted properly
                          # alongside all other revisions. This way the post-processing
                          # sort+grep+head will yield the revision that should carry the
                          # "latest" moniker
                          echo "${LATEST_REVISION}"
                          aws ecr-public describe-images --repository-name "${IMAGE_NAME}" | \
                              jq -r "${JQ_FIND_IMAGE_TAGS}"
                      ) | \
                      egrep "${RE_REVISION_SELECTOR}" | \
                      sort --reverse --version-sort --unique | \
                      head -1
                  )"
                  if [ "${LATEST_PUB}" == "${LATEST_REVISION}" ] ; then
                      BUILD="${ECR_REGISTRY_PUBLIC}/${IMAGE_URI}:${LATEST}"
                      echo "BUILDS+=(${BUILD@Q})" >> .env
                      TAGS+=(--tag "${BUILD}")
                      "${LATEST_ADDED}" || REVISIONS+=("${LATEST}")
                      LATEST_ADDED="true"
                  fi
              fi
          fi

          set -x
          docker build "${BUILD_ARGS[@]}" "${TAGS[@]}" .
          set +x

          # Once the build succeeds, we create the required tags as appropriate
          if [ -z "${REVISION_PRERELEASE}" ] ; then
              PREFIX="release"
          elif "${REVISION_SNAPSHOT}" ; then
              PREFIX="snapshot"
          else
              PREFIX="test"
          fi

          # If we want to tag the repository, do so! Clobber any existing tags!
          for R in "${REVISIONS[@]}" ; do
              # Tags for GIT must be the *real* revision, with "+" instead of "_"
              git tag --force "${PREFIX}/${R//_/+}"
          done
          git push --force --tags

      - name: Create Private ECR Repo
        run: |
          source .env
          cat .env

          # All images have private repositories
          echo "Creating the private repository for ${IMAGE_URI}..."
          aws ecr create-repository \
             --repository-name "${IMAGE_URI}" \
             --region "${ECR_AWS_REGION}" \
             --image-tag-mutability MUTABLE \
             --image-scanning-configuration scanOnPush=true  \
             --encryption-configuration encryptionType="AES256" || true

      - name: Create Public ECR Repo (if applicable)
        run: |
          source .env
          cat .env
          "${PUSH_TO_PUBLIC}" || exit 0

          IMAGE_REAL_URI="${IMAGE_URI}"
          [[ "${IMAGE_URI}" =~ ^arkcase/(.*)$ ]] && IMAGE_REAL_URI="${BASH_REMATCH[1]}"
          echo "Creating the public repository for ${IMAGE_URI} (as ${IMAGE_REAL_URI})..."
          aws ecr-public create-repository \
             --repository-name "${IMAGE_REAL_URI}" \
             --region "${ECR_AWS_REGION}" || true

      - name: Create Access Permissions
        run: |
          source .env
          cat .env

          cat << POL_STATEMENT > ecr_read_policy.json
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "org-ecr-read",
                "Effect": "Allow",
                "Principal": "*",
                "Action": [
                  "ecr:BatchCheckLayerAvailability",
                  "ecr:BatchGetImage",
                  "ecr:DescribeImageScanFindings",
                  "ecr:DescribeImages",
                  "ecr:DescribeRepositories",
                  "ecr:GetDownloadUrlForLayer",
                  "ecr:GetLifecyclePolicy",
                  "ecr:GetLifecyclePolicyPreview",
                  "ecr:GetRepositoryPolicy",
                  "ecr:ListImages",
                  "ecr:ListTagsForResource"
                ],
                "Condition": {
                  "ForAnyValue:StringEquals": {
                    "aws:PrincipalOrgID": [
                      "${ECR_AWS_ORG_ID}"
                    ]
                  }
                }
              },
              {
                  "Sid": "vendor-ecr-read",
                  "Effect": "Allow",
                  "Principal": {
                      "AWS": "arn:aws:iam::076340917683:root"
                  },
                  "Action": [
                      "ecr:BatchCheckLayerAvailability",
                      "ecr:BatchGetImage",
                      "ecr:DescribeImageScanFindings",
                      "ecr:DescribeImages",
                      "ecr:DescribeRepositories",
                      "ecr:GetDownloadUrlForLayer",
                      "ecr:GetLifecyclePolicy",
                      "ecr:GetLifecyclePolicyPreview",
                      "ecr:GetRepositoryPolicy",
                      "ecr:ListImages",
                      "ecr:ListTagsForResource"
                  ]
              }
            ]
          }
          POL_STATEMENT

      - name: Update Repository Permissions
        run: |
          source .env
          cat .env

          echo "${IMAGE_URI}"
          aws ecr set-repository-policy \
              --region "${ECR_AWS_REGION}" \
              --repository-name "${IMAGE_URI}" \
              --policy-text file://ecr_read_policy.json

      - name: Create Lifecycle Policy
        run: |
          source .env
          cat .env

          cat << LIFECYCLE_STATEMENT > ecr_lifecycle_policy.json
          {
            "rules": [
              {
                "rulePriority": 100,
                "description": "Keep only ten images, expire all others",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
          LIFECYCLE_STATEMENT

      - name: Update Repository Lifecycle Policy
        run: |
          source .env
          cat .env

          cat ecr_lifecycle_policy.json
          aws ecr put-lifecycle-policy \
              --region "${ECR_AWS_REGION}" \
              --repository-name "${IMAGE_URI}" \
              --lifecycle-policy-text file://ecr_lifecycle_policy.json

      - name: Publish Docker image
        run: |
          source .env
          cat .env

          # Iterate over the array of built artifacts, and push them
          for BUILD in "${BUILDS[@]}" ; do
              echo "Pushing [${BUILD}] ..."
              docker push "${BUILD}"
          done
