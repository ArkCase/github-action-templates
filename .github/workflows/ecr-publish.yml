name: ECR Dependencies and Push Images
on:
  workflow_call:
    secrets:
      ECR_AWS_REGION:
        required: true
      ECR_AWS_ORG_ID:
        required: true
      ECR_AWS_ACCESS_KEY:
        required: true
      ECR_AWS_ACCOUNT_ID:
        required: true
      ECR_SECRET_ACCESS_KEY:
        required: true

env:
  ECR_AWS_REGION: ${{ secrets.ECR_AWS_REGION }}
  ECR_AWS_ORG_ID: ${{ secrets.ECR_AWS_ORG_ID }}
jobs:
  ECR-Publishing:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.ECR_AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.ECR_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.ECR_AWS_REGION }}
          mask-aws-account-id: ${{ secrets.ECR_AWS_ACCOUNT_ID }}

      - name: Public or Private Repo
        run: |
          echo "We default to private for now. Public operations TBD"
          export VISIBILITY="private"
          [ "${VISIBILITY}" == "public" ] && VISIBILITY="public"
          echo "export VISIBILITY='${VISIBILITY}'" > .env

      - name: Create ECR Repo
        run: |
          source .env

          # Assume the default is "devel", until proven otherwise
          export ENVIRONMENT="devel"
          # This makes it easier to add special branch handlers later on
          case "${GITHUB_REF}" in
              "refs/heads/main" ) ENVIRONMENT="stable" ;;
          esac

          # TODO: Support finding the image name from a subfolder, where applicable

          # Split into an array of parts, making sure that double slashes, if present, are condensed into one
          # Also remove leading and trailing slashes, for safety. Also, fold it to lowercase
          readarray -d / -t PARTS < <(echo -n "${GITHUB_REPOSITORY,,}" | sed -e 's;^/*;;g' -e 's;/*$;;g' -e 's;/\+;/;g')

          # So at this point we know that PARTS[0] is the product suite (ArkCase, for instance), and PARTS[1] is the
          # repository name (i.e. ark_something-or-other)
          export PRODUCT_SUITE="${PARTS[0]}"
          export IMAGE_NAME="${PARTS[1]}"

          # Also, to support more product suites in the future...
          case "${PRODUCT_SUITE}" in
              "arkcase" ) IMAGE_NAME="$(echo -n "${IMAGE_NAME}" | sed -e 's;^ark_;;g')" ;;
          esac

          export IMAGE_URI="${PRODUCT_SUITE}"
          case "${VISIBILITY}" in
              "public" ) IMAGE_URI+="/${ENVIRONMENT}" ;;
              "private" ) ;;
          esac
          IMAGE_URI+="/${IMAGE_NAME}"

          echo "We are creating an image for the ${GITHUB_REPOSITORY}@${ENVIRONMENT}. This is based off of the repository name and Git branch."
          echo "We try creating this even if the repo exists, so errors to that note will not create failures of the workflow."
          aws ecr create-repository \
             --region "${ECR_AWS_REGION}" \
             --repository-name "${IMAGE_URI}" \
             --image-tag-mutability MUTABLE \
             --image-scanning-configuration scanOnPush=true  \
             --encryption-configuration encryptionType="AES256" || true

          # Stow the computed values for future consumption
          echo "export PRODUCT_SUITE=${PRODUCT_SUITE@Q}" >> .env
          echo "export ENVIRONMENT=${ENVIRONMENT@Q}" >> .env
          echo "export IMAGE_NAME=${IMAGE_NAME@Q}" >> .env
          echo "export IMAGE_URI=${IMAGE_URI@Q}" >> .env

      - name: Create Access Permissions
        run: |
          source .env
          cat << POL_STATEMENT > ecr_read_policy.json
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "org-ecr-read",
                "Effect": "Allow",
                "Principal": "*",
                "Action": [
                  "ecr:BatchCheckLayerAvailability",
                  "ecr:BatchGetImage",
                  "ecr:DescribeImageScanFindings",
                  "ecr:DescribeImages",
                  "ecr:DescribeRepositories",
                  "ecr:GetDownloadUrlForLayer",
                  "ecr:GetLifecyclePolicy",
                  "ecr:GetLifecyclePolicyPreview",
                  "ecr:GetRepositoryPolicy",
                  "ecr:ListImages",
                  "ecr:ListTagsForResource"
                ],
                "Condition": {
                  "ForAnyValue:StringEquals": {
                    "aws:PrincipalOrgID": [
                      "${ECR_AWS_ORG_ID}"
                    ]
                  }
                }
              }
            ]
          }
          POL_STATEMENT

      - name: Update Repository Permissions
        run: |
          source .env
          echo "${IMAGE_URI}"
          aws ecr set-repository-policy \
          --region "${ECR_AWS_REGION}" \
          --repository-name "${IMAGE_URI}" \
          --policy-text file://ecr_read_policy.json

      - name: Create Lifecycle Policy
        run: |
          cat << LIFECYCLE_STATEMENT > ecr_lifecycle_policy.json
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only ten images, expire all others",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
          LIFECYCLE_STATEMENT

      - name: Update Repository Lifecycle Policy
        run: |
          source .env
          cat ecr_lifecycle_policy.json
          aws ecr put-lifecycle-policy \
          --region "${ECR_AWS_REGION}" \
          --repository-name "${IMAGE_URI}" \
          --lifecycle-policy-text file://ecr_lifecycle_policy.json

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          source .env
          export TAG="$(grep "^[[:space:]]*ARG[[:space:]]+VER[[:space:]]*=" Dockerfile | head -1 | sed -e 's;^[^=]*=\s*\(.*\)$;\1;g' -e 's;\s*$;;g')"
          # If the value is wrapped in quotes, then we eval it
          if [[ "${TAG}" =~ ^".*"$ ]] || [[ "${TAG}" =~ ^'.*'$ ]] ; then
              eval "TAG=${TAG}"
          fi
          echo "export IMAGE_TAG=${TAG@Q}" >> .env
          cat .env
          export IMAGE_FULL_URI="${ECR_REGISTRY}/${IMAGE_URI}"
          echo "export IMAGE_FULL_URI=${IMAGE_FULL_URI@Q}" >> .env
          export BUILD="${IMAGE_FULL_URI}:${TAG}"
          echo "export BUILDS=()" >> .env
          echo "BUILDS+=(${BUILD@Q})" >> .env
          ARGS=(-t "${BUILD}")
          if [ "${ENVIRONMENT}" == "stable" ] ; then
              export LATEST="${IMAGE}:latest"
              echo "BUILDS+=(${LATEST@Q})" >> .env
              ARGS+=(-t "${LATEST}")
          else
              echo "latest tag not required"
          fi
          set -x
          docker build "${ARGS[@]}" .

      - name: Publish Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          source .env
          # Iterate over the array of built artifacts, and push them
          for BUILD in "${BUILDS[@]}" ; do
              docker push "${BUILD}"
          done
